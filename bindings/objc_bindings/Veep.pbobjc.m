// Generated by the protocol buffer compiler.  DO NOT EDIT!
// clang-format off
// source: veep.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30007
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30007 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

#import <stdatomic.h>

#import "Veep.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective-C Class declarations
// Forward declarations of Objective-C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(VPKPDiscreteTime);
GPBObjCClassDeclaration(VPKPDiscreteTimeRange);
GPBObjCClassDeclaration(VPKPDiscreteTimeRangeRect);
GPBObjCClassDeclaration(VPKPDiscreteTimeRangeRectValidationError);
GPBObjCClassDeclaration(VPKPDiscreteTimeRangeValidationError);
GPBObjCClassDeclaration(VPKPDiscreteTimeValidationError);
GPBObjCClassDeclaration(VPKPErrorResponse);
GPBObjCClassDeclaration(VPKPRect);
GPBObjCClassDeclaration(VPKPRectValidationError);
GPBObjCClassDeclaration(VPKPVeep);
GPBObjCClassDeclaration(VPKPVeepHeader);
GPBObjCClassDeclaration(VPKPVeepHeaderContainer);
GPBObjCClassDeclaration(VPKPVeepHeaderContainerValidationError);
GPBObjCClassDeclaration(VPKPVeepHeaderValidationError);
GPBObjCClassDeclaration(VPKPVeepTrackElement);
GPBObjCClassDeclaration(VPKPVeepTrackElementContainer);
GPBObjCClassDeclaration(VPKPVeepTrackElementContainerValidationError);
GPBObjCClassDeclaration(VPKPVeepTrackElementValidationError);
GPBObjCClassDeclaration(VPKPVeepTrackHeader);
GPBObjCClassDeclaration(VPKPVeepTrackHeaderValidationError);
GPBObjCClassDeclaration(VPKPVeepTrackTag);
GPBObjCClassDeclaration(VPKPVeepTrackTagValidationError);
GPBObjCClassDeclaration(VPKPVeepValidationError);

#pragma mark - VPKPVeepRoot

@implementation VPKPVeepRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

static GPBFileDescription VPKPVeepRoot_FileDescription = {
  .package = "veepio",
  .prefix = "VPKP",
  .syntax = GPBFileSyntaxProto3
};

#pragma mark - Enum VPKPVeepTrackHeader_VeepTrackType

GPBEnumDescriptor *VPKPVeepTrackHeader_VeepTrackType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static const char *valueNames =
        "URL\000Retail\000Blog\000";
    static const int32_t values[] = {
        VPKPVeepTrackHeader_VeepTrackType_URL,
        VPKPVeepTrackHeader_VeepTrackType_Retail,
        VPKPVeepTrackHeader_VeepTrackType_Blog,
    };
    static const char *extraTextFormatInfo = "\001\000\003\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(VPKPVeepTrackHeader_VeepTrackType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:VPKPVeepTrackHeader_VeepTrackType_IsValidValue
                                            flags:GPBEnumDescriptorInitializationFlag_None
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL VPKPVeepTrackHeader_VeepTrackType_IsValidValue(int32_t value__) {
  switch (value__) {
    case VPKPVeepTrackHeader_VeepTrackType_URL:
    case VPKPVeepTrackHeader_VeepTrackType_Retail:
    case VPKPVeepTrackHeader_VeepTrackType_Blog:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - VPKPVeep

@implementation VPKPVeep

@dynamic hasHeader, header;
@dynamic trackElementsArray, trackElementsArray_Count;

typedef struct VPKPVeep__storage_ {
  uint32_t _has_storage_[1];
  VPKPVeepHeader *header;
  NSMutableArray *trackElementsArray;
} VPKPVeep__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPVeepHeader),
        .number = VPKPVeep_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VPKPVeep__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "trackElementsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPVeepTrackElement),
        .number = VPKPVeep_FieldNumber_TrackElementsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeep__storage_, trackElementsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPVeep)
                                   messageName:@"Veep"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPVeep__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000trackElements\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VPKPVeepHeaderContainer

@implementation VPKPVeepHeaderContainer

@dynamic hasHeader, header;

typedef struct VPKPVeepHeaderContainer__storage_ {
  uint32_t _has_storage_[1];
  VPKPVeepHeader *header;
} VPKPVeepHeaderContainer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPVeepHeader),
        .number = VPKPVeepHeaderContainer_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VPKPVeepHeaderContainer__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPVeepHeaderContainer)
                                   messageName:@"VeepHeaderContainer"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPVeepHeaderContainer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VPKPVeepTrackElementContainer

@implementation VPKPVeepTrackElementContainer

@dynamic hasTrackElement, trackElement;

typedef struct VPKPVeepTrackElementContainer__storage_ {
  uint32_t _has_storage_[1];
  VPKPVeepTrackElement *trackElement;
} VPKPVeepTrackElementContainer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "trackElement",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPVeepTrackElement),
        .number = VPKPVeepTrackElementContainer_FieldNumber_TrackElement,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VPKPVeepTrackElementContainer__storage_, trackElement),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPVeepTrackElementContainer)
                                   messageName:@"VeepTrackElementContainer"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPVeepTrackElementContainer__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VPKPVeepHeader

@implementation VPKPVeepHeader

@dynamic identifier;
@dynamic title;
@dynamic description_p;
@dynamic creatorEmail;
@dynamic contentType;
@dynamic thumbnailData;
@dynamic originalContentUri;
@dynamic originalContentWidth;
@dynamic originalContentHeight;
@dynamic alternativeContentUrlsArray, alternativeContentUrlsArray_Count;
@dynamic originalIdentifier;
@dynamic previousIdentifier;
@dynamic previewURL;

typedef struct VPKPVeepHeader__storage_ {
  uint32_t _has_storage_[1];
  int32_t originalContentWidth;
  int32_t originalContentHeight;
  NSString *identifier;
  NSString *title;
  NSString *description_p;
  NSString *creatorEmail;
  NSData *thumbnailData;
  NSString *originalContentUri;
  NSString *contentType;
  NSString *originalIdentifier;
  NSString *previousIdentifier;
  NSMutableArray *alternativeContentUrlsArray;
  NSString *previewURL;
} VPKPVeepHeader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeader_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VPKPVeepHeader__storage_, identifier),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeader_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VPKPVeepHeader__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeader_FieldNumber_Description_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VPKPVeepHeader__storage_, description_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "creatorEmail",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeader_FieldNumber_CreatorEmail,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VPKPVeepHeader__storage_, creatorEmail),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thumbnailData",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeader_FieldNumber_ThumbnailData,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(VPKPVeepHeader__storage_, thumbnailData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "originalContentUri",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeader_FieldNumber_OriginalContentUri,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(VPKPVeepHeader__storage_, originalContentUri),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contentType",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeader_FieldNumber_ContentType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(VPKPVeepHeader__storage_, contentType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "originalContentWidth",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeader_FieldNumber_OriginalContentWidth,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(VPKPVeepHeader__storage_, originalContentWidth),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "originalContentHeight",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeader_FieldNumber_OriginalContentHeight,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(VPKPVeepHeader__storage_, originalContentHeight),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "originalIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeader_FieldNumber_OriginalIdentifier,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(VPKPVeepHeader__storage_, originalIdentifier),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "previousIdentifier",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeader_FieldNumber_PreviousIdentifier,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(VPKPVeepHeader__storage_, previousIdentifier),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alternativeContentUrlsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeader_FieldNumber_AlternativeContentUrlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepHeader__storage_, alternativeContentUrlsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "previewURL",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeader_FieldNumber_PreviewURL,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(VPKPVeepHeader__storage_, previewURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPVeepHeader)
                                   messageName:@"VeepHeader"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPVeepHeader__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\n\004\014\000\005\r\000\006\020b\000\007\013\000\010\024\000\t\025\000\n\022\000\013\022\000\014\000alternativeC"
        "ontentURLs\000\r\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VPKPVeepTrackHeader

@implementation VPKPVeepTrackHeader

@dynamic identifier;
@dynamic title;
@dynamic description_p;
@dynamic URL;
@dynamic type;

typedef struct VPKPVeepTrackHeader__storage_ {
  uint32_t _has_storage_[1];
  VPKPVeepTrackHeader_VeepTrackType type;
  NSString *identifier;
  NSString *title;
  NSString *description_p;
  NSString *URL;
} VPKPVeepTrackHeader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepTrackHeader_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VPKPVeepTrackHeader__storage_, identifier),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepTrackHeader_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VPKPVeepTrackHeader__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepTrackHeader_FieldNumber_Description_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VPKPVeepTrackHeader__storage_, description_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepTrackHeader_FieldNumber_URL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VPKPVeepTrackHeader__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = VPKPVeepTrackHeader_VeepTrackType_EnumDescriptor,
        .number = VPKPVeepTrackHeader_FieldNumber_Type,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(VPKPVeepTrackHeader__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPVeepTrackHeader)
                                   messageName:@"VeepTrackHeader"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPVeepTrackHeader__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t VPKPVeepTrackHeader_Type_RawValue(VPKPVeepTrackHeader *message) {
  GPBDescriptor *descriptor = [VPKPVeepTrackHeader descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:VPKPVeepTrackHeader_FieldNumber_Type];
  return GPBGetMessageRawEnumField(message, field);
}

void SetVPKPVeepTrackHeader_Type_RawValue(VPKPVeepTrackHeader *message, int32_t value) {
  GPBDescriptor *descriptor = [VPKPVeepTrackHeader descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:VPKPVeepTrackHeader_FieldNumber_Type];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - VPKPVeepTrackTag

@implementation VPKPVeepTrackTag

@dynamic identifier;

typedef struct VPKPVeepTrackTag__storage_ {
  uint32_t _has_storage_[1];
  NSString *identifier;
} VPKPVeepTrackTag__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifier",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepTrackTag_FieldNumber_Identifier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VPKPVeepTrackTag__storage_, identifier),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPVeepTrackTag)
                                   messageName:@"VeepTrackTag"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPVeepTrackTag__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VPKPRect

@implementation VPKPRect

@dynamic x;
@dynamic y;
@dynamic width;
@dynamic height;

typedef struct VPKPRect__storage_ {
  uint32_t _has_storage_[1];
  float x;
  float y;
  float width;
  float height;
} VPKPRect__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "x",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPRect_FieldNumber_X,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VPKPRect__storage_, x),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "y",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPRect_FieldNumber_Y,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VPKPRect__storage_, y),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "width",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPRect_FieldNumber_Width,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VPKPRect__storage_, width),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "height",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPRect_FieldNumber_Height,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VPKPRect__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPRect)
                                   messageName:@"Rect"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPRect__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VPKPDiscreteTime

@implementation VPKPDiscreteTime

@dynamic timescale;
@dynamic value;

typedef struct VPKPDiscreteTime__storage_ {
  uint32_t _has_storage_[1];
  int32_t timescale;
  int64_t value;
} VPKPDiscreteTime__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timescale",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPDiscreteTime_FieldNumber_Timescale,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VPKPDiscreteTime__storage_, timescale),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPDiscreteTime_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VPKPDiscreteTime__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPDiscreteTime)
                                   messageName:@"DiscreteTime"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPDiscreteTime__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VPKPDiscreteTimeRange

@implementation VPKPDiscreteTimeRange

@dynamic hasStart, start;
@dynamic hasDuration, duration;

typedef struct VPKPDiscreteTimeRange__storage_ {
  uint32_t _has_storage_[1];
  VPKPDiscreteTime *start;
  VPKPDiscreteTime *duration;
} VPKPDiscreteTimeRange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPDiscreteTime),
        .number = VPKPDiscreteTimeRange_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VPKPDiscreteTimeRange__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "duration",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPDiscreteTime),
        .number = VPKPDiscreteTimeRange_FieldNumber_Duration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VPKPDiscreteTimeRange__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPDiscreteTimeRange)
                                   messageName:@"DiscreteTimeRange"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPDiscreteTimeRange__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VPKPDiscreteTimeRangeRect

@implementation VPKPDiscreteTimeRangeRect

@dynamic hasTimeRange, timeRange;
@dynamic hasRect, rect;

typedef struct VPKPDiscreteTimeRangeRect__storage_ {
  uint32_t _has_storage_[1];
  VPKPDiscreteTimeRange *timeRange;
  VPKPRect *rect;
} VPKPDiscreteTimeRangeRect__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timeRange",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPDiscreteTimeRange),
        .number = VPKPDiscreteTimeRangeRect_FieldNumber_TimeRange,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VPKPDiscreteTimeRangeRect__storage_, timeRange),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rect",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPRect),
        .number = VPKPDiscreteTimeRangeRect_FieldNumber_Rect,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VPKPDiscreteTimeRangeRect__storage_, rect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPDiscreteTimeRangeRect)
                                   messageName:@"DiscreteTimeRangeRect"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPDiscreteTimeRangeRect__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VPKPVeepTrackElement

@implementation VPKPVeepTrackElement

@dynamic metaOneOfCase;
@dynamic dataOneOfCase;
@dynamic header;
@dynamic tag;
@dynamic discreteTimeRangeRect;
@dynamic rect;

typedef struct VPKPVeepTrackElement__storage_ {
  uint32_t _has_storage_[3];
  VPKPVeepTrackHeader *header;
  VPKPVeepTrackTag *tag;
  VPKPDiscreteTimeRangeRect *discreteTimeRangeRect;
  VPKPRect *rect;
} VPKPVeepTrackElement__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPVeepTrackHeader),
        .number = VPKPVeepTrackElement_FieldNumber_Header,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(VPKPVeepTrackElement__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tag",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPVeepTrackTag),
        .number = VPKPVeepTrackElement_FieldNumber_Tag,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(VPKPVeepTrackElement__storage_, tag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "discreteTimeRangeRect",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPDiscreteTimeRangeRect),
        .number = VPKPVeepTrackElement_FieldNumber_DiscreteTimeRangeRect,
        .hasIndex = -2,
        .offset = (uint32_t)offsetof(VPKPVeepTrackElement__storage_, discreteTimeRangeRect),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rect",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPRect),
        .number = VPKPVeepTrackElement_FieldNumber_Rect,
        .hasIndex = -2,
        .offset = (uint32_t)offsetof(VPKPVeepTrackElement__storage_, rect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPVeepTrackElement)
                                   messageName:@"VeepTrackElement"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPVeepTrackElement__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    static const char *oneofs[] = {
      "meta",
      "data",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\t\025\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void VPKPVeepTrackElement_ClearMetaOneOfCase(VPKPVeepTrackElement *message) {
  GPBDescriptor *descriptor = [VPKPVeepTrackElement descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
void VPKPVeepTrackElement_ClearDataOneOfCase(VPKPVeepTrackElement *message) {
  GPBDescriptor *descriptor = [VPKPVeepTrackElement descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:1];
  GPBClearOneof(message, oneof);
}
#pragma mark - VPKPErrorResponse

@implementation VPKPErrorResponse

@dynamic detail;

typedef struct VPKPErrorResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *detail;
} VPKPErrorResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "detail",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPErrorResponse_FieldNumber_Detail,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VPKPErrorResponse__storage_, detail),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPErrorResponse)
                                   messageName:@"ErrorResponse"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPErrorResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VPKPVeepValidationError

@implementation VPKPVeepValidationError

@dynamic hasHeader, header;
@dynamic trackElementsArray, trackElementsArray_Count;
@dynamic nonFieldErrorsArray, nonFieldErrorsArray_Count;

typedef struct VPKPVeepValidationError__storage_ {
  uint32_t _has_storage_[1];
  VPKPVeepHeaderValidationError *header;
  NSMutableArray *nonFieldErrorsArray;
  NSMutableArray *trackElementsArray;
} VPKPVeepValidationError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPVeepHeaderValidationError),
        .number = VPKPVeepValidationError_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VPKPVeepValidationError__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nonFieldErrorsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepValidationError_FieldNumber_NonFieldErrorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepValidationError__storage_, nonFieldErrorsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "trackElementsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPVeepTrackElementValidationError),
        .number = VPKPVeepValidationError_FieldNumber_TrackElementsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepValidationError__storage_, trackElementsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPVeepValidationError)
                                   messageName:@"VeepValidationError"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPVeepValidationError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\000trackElements\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VPKPVeepHeaderContainerValidationError

@implementation VPKPVeepHeaderContainerValidationError

@dynamic hasHeader, header;
@dynamic nonFieldErrorsArray, nonFieldErrorsArray_Count;

typedef struct VPKPVeepHeaderContainerValidationError__storage_ {
  uint32_t _has_storage_[1];
  VPKPVeepHeaderValidationError *header;
  NSMutableArray *nonFieldErrorsArray;
} VPKPVeepHeaderContainerValidationError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPVeepHeaderValidationError),
        .number = VPKPVeepHeaderContainerValidationError_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VPKPVeepHeaderContainerValidationError__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nonFieldErrorsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeaderContainerValidationError_FieldNumber_NonFieldErrorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepHeaderContainerValidationError__storage_, nonFieldErrorsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPVeepHeaderContainerValidationError)
                                   messageName:@"VeepHeaderContainerValidationError"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPVeepHeaderContainerValidationError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VPKPVeepTrackElementContainerValidationError

@implementation VPKPVeepTrackElementContainerValidationError

@dynamic hasTrackElement, trackElement;
@dynamic nonFieldErrorsArray, nonFieldErrorsArray_Count;

typedef struct VPKPVeepTrackElementContainerValidationError__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *nonFieldErrorsArray;
  VPKPVeepTrackElementValidationError *trackElement;
} VPKPVeepTrackElementContainerValidationError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nonFieldErrorsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepTrackElementContainerValidationError_FieldNumber_NonFieldErrorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepTrackElementContainerValidationError__storage_, nonFieldErrorsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "trackElement",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPVeepTrackElementValidationError),
        .number = VPKPVeepTrackElementContainerValidationError_FieldNumber_TrackElement,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VPKPVeepTrackElementContainerValidationError__storage_, trackElement),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPVeepTrackElementContainerValidationError)
                                   messageName:@"VeepTrackElementContainerValidationError"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPVeepTrackElementContainerValidationError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VPKPVeepHeaderValidationError

@implementation VPKPVeepHeaderValidationError

@dynamic identifierArray, identifierArray_Count;
@dynamic titleArray, titleArray_Count;
@dynamic descriptionArray, descriptionArray_Count;
@dynamic creatorEmailArray, creatorEmailArray_Count;
@dynamic contentTypeArray, contentTypeArray_Count;
@dynamic thumbnailDataArray, thumbnailDataArray_Count;
@dynamic originalContentUriArray, originalContentUriArray_Count;
@dynamic originalContentWidthArray, originalContentWidthArray_Count;
@dynamic originalContentHeightArray, originalContentHeightArray_Count;
@dynamic alternativeContentUrlsArray, alternativeContentUrlsArray_Count;
@dynamic originalIdentifierArray, originalIdentifierArray_Count;
@dynamic previousIdentifierArray, previousIdentifierArray_Count;
@dynamic nonFieldErrorsArray, nonFieldErrorsArray_Count;

typedef struct VPKPVeepHeaderValidationError__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *identifierArray;
  NSMutableArray *titleArray;
  NSMutableArray *descriptionArray;
  NSMutableArray *creatorEmailArray;
  NSMutableArray *thumbnailDataArray;
  NSMutableArray *originalContentUriArray;
  NSMutableArray *contentTypeArray;
  NSMutableArray *nonFieldErrorsArray;
  NSMutableArray *originalContentHeightArray;
  NSMutableArray *originalContentWidthArray;
  NSMutableArray *originalIdentifierArray;
  NSMutableArray *previousIdentifierArray;
  NSMutableArray *alternativeContentUrlsArray;
} VPKPVeepHeaderValidationError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifierArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeaderValidationError_FieldNumber_IdentifierArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepHeaderValidationError__storage_, identifierArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "titleArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeaderValidationError_FieldNumber_TitleArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepHeaderValidationError__storage_, titleArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "descriptionArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeaderValidationError_FieldNumber_DescriptionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepHeaderValidationError__storage_, descriptionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "creatorEmailArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeaderValidationError_FieldNumber_CreatorEmailArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepHeaderValidationError__storage_, creatorEmailArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thumbnailDataArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeaderValidationError_FieldNumber_ThumbnailDataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepHeaderValidationError__storage_, thumbnailDataArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "originalContentUriArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeaderValidationError_FieldNumber_OriginalContentUriArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepHeaderValidationError__storage_, originalContentUriArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contentTypeArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeaderValidationError_FieldNumber_ContentTypeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepHeaderValidationError__storage_, contentTypeArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nonFieldErrorsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeaderValidationError_FieldNumber_NonFieldErrorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepHeaderValidationError__storage_, nonFieldErrorsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "originalContentHeightArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeaderValidationError_FieldNumber_OriginalContentHeightArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepHeaderValidationError__storage_, originalContentHeightArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "originalContentWidthArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeaderValidationError_FieldNumber_OriginalContentWidthArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepHeaderValidationError__storage_, originalContentWidthArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "originalIdentifierArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeaderValidationError_FieldNumber_OriginalIdentifierArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepHeaderValidationError__storage_, originalIdentifierArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "previousIdentifierArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeaderValidationError_FieldNumber_PreviousIdentifierArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepHeaderValidationError__storage_, previousIdentifierArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alternativeContentUrlsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepHeaderValidationError_FieldNumber_AlternativeContentUrlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepHeaderValidationError__storage_, alternativeContentUrlsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPVeepHeaderValidationError)
                                   messageName:@"VeepHeaderValidationError"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPVeepHeaderValidationError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\t\004\000creatorEmail\000\005\000thumbnailData\000\006\000origin"
        "alContentURI\000\007\000contentType\000\n\000originalCon"
        "tentHeight\000\013\000originalContentWidth\000\014\000orig"
        "inalIdentifier\000\r\000previousIdentifier\000\016\000al"
        "ternativeContentURLs\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VPKPVeepTrackHeaderValidationError

@implementation VPKPVeepTrackHeaderValidationError

@dynamic identifierArray, identifierArray_Count;
@dynamic titleArray, titleArray_Count;
@dynamic descriptionArray, descriptionArray_Count;
@dynamic URLArray, URLArray_Count;
@dynamic typeArray, typeArray_Count;
@dynamic nonFieldErrorsArray, nonFieldErrorsArray_Count;

typedef struct VPKPVeepTrackHeaderValidationError__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *identifierArray;
  NSMutableArray *titleArray;
  NSMutableArray *descriptionArray;
  NSMutableArray *URLArray;
  NSMutableArray *typeArray;
  NSMutableArray *nonFieldErrorsArray;
} VPKPVeepTrackHeaderValidationError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifierArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepTrackHeaderValidationError_FieldNumber_IdentifierArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepTrackHeaderValidationError__storage_, identifierArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "titleArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepTrackHeaderValidationError_FieldNumber_TitleArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepTrackHeaderValidationError__storage_, titleArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "descriptionArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepTrackHeaderValidationError_FieldNumber_DescriptionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepTrackHeaderValidationError__storage_, descriptionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URLArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepTrackHeaderValidationError_FieldNumber_URLArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepTrackHeaderValidationError__storage_, URLArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "typeArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepTrackHeaderValidationError_FieldNumber_TypeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepTrackHeaderValidationError__storage_, typeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nonFieldErrorsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepTrackHeaderValidationError_FieldNumber_NonFieldErrorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepTrackHeaderValidationError__storage_, nonFieldErrorsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPVeepTrackHeaderValidationError)
                                   messageName:@"VeepTrackHeaderValidationError"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPVeepTrackHeaderValidationError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\000url\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VPKPVeepTrackTagValidationError

@implementation VPKPVeepTrackTagValidationError

@dynamic identifierArray, identifierArray_Count;
@dynamic nonFieldErrorsArray, nonFieldErrorsArray_Count;

typedef struct VPKPVeepTrackTagValidationError__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *identifierArray;
  NSMutableArray *nonFieldErrorsArray;
} VPKPVeepTrackTagValidationError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identifierArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepTrackTagValidationError_FieldNumber_IdentifierArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepTrackTagValidationError__storage_, identifierArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nonFieldErrorsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepTrackTagValidationError_FieldNumber_NonFieldErrorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepTrackTagValidationError__storage_, nonFieldErrorsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPVeepTrackTagValidationError)
                                   messageName:@"VeepTrackTagValidationError"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPVeepTrackTagValidationError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VPKPRectValidationError

@implementation VPKPRectValidationError

@dynamic xArray, xArray_Count;
@dynamic yArray, yArray_Count;
@dynamic widthArray, widthArray_Count;
@dynamic heightArray, heightArray_Count;
@dynamic nonFieldErrorsArray, nonFieldErrorsArray_Count;

typedef struct VPKPRectValidationError__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *xArray;
  NSMutableArray *yArray;
  NSMutableArray *widthArray;
  NSMutableArray *heightArray;
  NSMutableArray *nonFieldErrorsArray;
} VPKPRectValidationError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "xArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPRectValidationError_FieldNumber_XArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPRectValidationError__storage_, xArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "yArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPRectValidationError_FieldNumber_YArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPRectValidationError__storage_, yArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "widthArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPRectValidationError_FieldNumber_WidthArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPRectValidationError__storage_, widthArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "heightArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPRectValidationError_FieldNumber_HeightArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPRectValidationError__storage_, heightArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nonFieldErrorsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPRectValidationError_FieldNumber_NonFieldErrorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPRectValidationError__storage_, nonFieldErrorsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPRectValidationError)
                                   messageName:@"RectValidationError"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPRectValidationError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VPKPDiscreteTimeValidationError

@implementation VPKPDiscreteTimeValidationError

@dynamic timescaleArray, timescaleArray_Count;
@dynamic valueArray, valueArray_Count;
@dynamic nonFieldErrorsArray, nonFieldErrorsArray_Count;

typedef struct VPKPDiscreteTimeValidationError__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *timescaleArray;
  NSMutableArray *valueArray;
  NSMutableArray *nonFieldErrorsArray;
} VPKPDiscreteTimeValidationError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timescaleArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPDiscreteTimeValidationError_FieldNumber_TimescaleArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPDiscreteTimeValidationError__storage_, timescaleArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "valueArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPDiscreteTimeValidationError_FieldNumber_ValueArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPDiscreteTimeValidationError__storage_, valueArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nonFieldErrorsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPDiscreteTimeValidationError_FieldNumber_NonFieldErrorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPDiscreteTimeValidationError__storage_, nonFieldErrorsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPDiscreteTimeValidationError)
                                   messageName:@"DiscreteTimeValidationError"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPDiscreteTimeValidationError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VPKPDiscreteTimeRangeValidationError

@implementation VPKPDiscreteTimeRangeValidationError

@dynamic hasStart, start;
@dynamic hasDuration, duration;
@dynamic nonFieldErrorsArray, nonFieldErrorsArray_Count;

typedef struct VPKPDiscreteTimeRangeValidationError__storage_ {
  uint32_t _has_storage_[1];
  VPKPDiscreteTimeValidationError *start;
  VPKPDiscreteTimeValidationError *duration;
  NSMutableArray *nonFieldErrorsArray;
} VPKPDiscreteTimeRangeValidationError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPDiscreteTimeValidationError),
        .number = VPKPDiscreteTimeRangeValidationError_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VPKPDiscreteTimeRangeValidationError__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "duration",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPDiscreteTimeValidationError),
        .number = VPKPDiscreteTimeRangeValidationError_FieldNumber_Duration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VPKPDiscreteTimeRangeValidationError__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nonFieldErrorsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPDiscreteTimeRangeValidationError_FieldNumber_NonFieldErrorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPDiscreteTimeRangeValidationError__storage_, nonFieldErrorsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPDiscreteTimeRangeValidationError)
                                   messageName:@"DiscreteTimeRangeValidationError"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPDiscreteTimeRangeValidationError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VPKPDiscreteTimeRangeRectValidationError

@implementation VPKPDiscreteTimeRangeRectValidationError

@dynamic hasTimeRange, timeRange;
@dynamic hasRect, rect;
@dynamic nonFieldErrorsArray, nonFieldErrorsArray_Count;

typedef struct VPKPDiscreteTimeRangeRectValidationError__storage_ {
  uint32_t _has_storage_[1];
  VPKPDiscreteTimeRangeValidationError *timeRange;
  VPKPRectValidationError *rect;
  NSMutableArray *nonFieldErrorsArray;
} VPKPDiscreteTimeRangeRectValidationError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timeRange",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPDiscreteTimeRangeValidationError),
        .number = VPKPDiscreteTimeRangeRectValidationError_FieldNumber_TimeRange,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VPKPDiscreteTimeRangeRectValidationError__storage_, timeRange),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rect",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPRectValidationError),
        .number = VPKPDiscreteTimeRangeRectValidationError_FieldNumber_Rect,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VPKPDiscreteTimeRangeRectValidationError__storage_, rect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nonFieldErrorsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPDiscreteTimeRangeRectValidationError_FieldNumber_NonFieldErrorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPDiscreteTimeRangeRectValidationError__storage_, nonFieldErrorsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPDiscreteTimeRangeRectValidationError)
                                   messageName:@"DiscreteTimeRangeRectValidationError"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPDiscreteTimeRangeRectValidationError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VPKPVeepTrackElementValidationError

@implementation VPKPVeepTrackElementValidationError

@dynamic metaOneOfCase;
@dynamic dataOneOfCase;
@dynamic header;
@dynamic tag;
@dynamic discreteTimeRangeRect;
@dynamic rect;
@dynamic index;
@dynamic nonFieldErrorsArray, nonFieldErrorsArray_Count;

typedef struct VPKPVeepTrackElementValidationError__storage_ {
  uint32_t _has_storage_[3];
  VPKPVeepTrackHeaderValidationError *header;
  VPKPVeepTrackTagValidationError *tag;
  VPKPDiscreteTimeRangeRectValidationError *discreteTimeRangeRect;
  VPKPRectValidationError *rect;
  NSString *index;
  NSMutableArray *nonFieldErrorsArray;
} VPKPVeepTrackElementValidationError__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPVeepTrackHeaderValidationError),
        .number = VPKPVeepTrackElementValidationError_FieldNumber_Header,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(VPKPVeepTrackElementValidationError__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tag",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPVeepTrackTagValidationError),
        .number = VPKPVeepTrackElementValidationError_FieldNumber_Tag,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(VPKPVeepTrackElementValidationError__storage_, tag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "discreteTimeRangeRect",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPDiscreteTimeRangeRectValidationError),
        .number = VPKPVeepTrackElementValidationError_FieldNumber_DiscreteTimeRangeRect,
        .hasIndex = -2,
        .offset = (uint32_t)offsetof(VPKPVeepTrackElementValidationError__storage_, discreteTimeRangeRect),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rect",
        .dataTypeSpecific.clazz = GPBObjCClass(VPKPRectValidationError),
        .number = VPKPVeepTrackElementValidationError_FieldNumber_Rect,
        .hasIndex = -2,
        .offset = (uint32_t)offsetof(VPKPVeepTrackElementValidationError__storage_, rect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepTrackElementValidationError_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VPKPVeepTrackElementValidationError__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nonFieldErrorsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = VPKPVeepTrackElementValidationError_FieldNumber_NonFieldErrorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VPKPVeepTrackElementValidationError__storage_, nonFieldErrorsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:GPBObjCClass(VPKPVeepTrackElementValidationError)
                                   messageName:@"VeepTrackElementValidationError"
                               fileDescription:&VPKPVeepRoot_FileDescription
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VPKPVeepTrackElementValidationError__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_ClosedEnumSupportKnown)];
    static const char *oneofs[] = {
      "meta",
      "data",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\t\025\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void VPKPVeepTrackElementValidationError_ClearMetaOneOfCase(VPKPVeepTrackElementValidationError *message) {
  GPBDescriptor *descriptor = [VPKPVeepTrackElementValidationError descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
void VPKPVeepTrackElementValidationError_ClearDataOneOfCase(VPKPVeepTrackElementValidationError *message) {
  GPBDescriptor *descriptor = [VPKPVeepTrackElementValidationError descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:1];
  GPBClearOneof(message, oneof);
}

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

// clang-format on
